---
title: 逻各斯与计算机编程艺术
author: Mudern
date: 2025-11-09 00:00:00
tags:
- 社论
cover: cover.webp
---

我一直有个“暴论”：**喜欢计算机的人，在学习计算机相关知识时，最理想的配比是——20% 哲学，80% 专业知识**。 因此，我想借这篇文章，聊一聊哲学与计算机之间的某种联结。

“哲学”一词源于古希腊语 *philosophia*，本意是“爱智慧”。有一句被反复引用的话大概可以表意为：惟有爱（*philein*），才能真正看见智慧（*sophia*）之光（*phaos*）。在哲学的传统分类中，人们通常把根本性问题分为几个主要领域：

1. **形而上学**：世界究竟“是什么”？何为“存在”的本质？

2. **认识论**：我们能否认识世界？知识从何而来，又止于何处？

3. **伦理学**：人应当如何行动？何为“好”的生活？

4. **逻辑学**：什么是正确的推理？推理的形式与规则如何表达？

5. **美学**：美是什么？我们如何感知与判断“美”？


这篇文章会主要围绕其中的**形而上学**展开。

早在古希腊，哲学家们就提出了“**逻各斯（Logos）**”这一概念，它深刻地影响了此后数千年的西方思想。在赫拉克利特那里，逻各斯是**贯穿宇宙万变之中的那条不变的理性秩序**，是我们看不到，摸不到却主宰了整个宇宙的“底层规则”。

如果我们把视线转向计算机世界：当我们设计程序、构造系统、发明语言时，其实也在追寻某种支配信息与计算的“底层逻各斯”。这正是《逻各斯与计算机编程艺术》这个标题的由来——当然，它是向我喜欢的一本书《禅与摩托车维修艺术》标题的致敬。

限于篇幅，这篇文章主要讨论两个观点。第一个核心观点是：**你对世界的理解越深刻，就越能简洁地描述它**。第二个核心观点则是：**当我们看待事物的角度发生变化，世界也就随之发生变化**。

# 观点一

你对世界的理解越深刻，就越能简洁地描述它。

我们常说，**软件工程是一门对抗现实复杂度的学科**。编程语言之所以叫“语言”，正是因为我们在用它向计算机**描述我们对现实世界的理解**。当我们对现实的理解越深刻，就越可能写出**更简洁、更准确的代码**。

通常在计算机领域，我们称这种东西为合理而正确的抽象。简洁并不是对复杂的粗暴删减，而是从纷繁现象中抽出真正本质的结构，用最少的符号捕捉最多的内容。数学家会称之为“优美”，工程师会说“优雅”，程序员则习惯叫它“干净的抽象”。

在物理学上我们可以找出一个很好的例子：**麦克斯韦方程组**。

它常被称为“物理学中最简洁、最具美感的一组公式之一”。先看它在不使用算子的展开形式（只展示结构，不深究物理细节）：

![不使用算子的麦克斯韦方程组](../photos/逻各斯与计算机编程艺术/1.svg)

如果我们引入矢量分析中的算子，他的形式将会被简化为：

![使用算子的麦克斯韦方程组](../photos/逻各斯与计算机编程艺术/2.svg)

这种写法上的变化不是一种数学游戏，而是对于麦克斯韦方程组认识的加深带来的自然而然的结果。在使用算子的这四条公式里，我们大致可以读出这样几条规则（略不严谨，但有助于直观）：

1. **静电场是有源无旋场，其散度在局部与电荷密度成正比。**

2. **静磁场是有旋无源场，其散度恒为零，旋度由电流决定。**

3. **随时间变化的磁场，会在空间中激发出有旋的电场。**

4. **随时间变化的电场与电流，会在空间中激发出有旋的磁场。**

当然，进一步，如果假设磁单极子存在，这组方程还能被推广成更对称的形式：

![假设存在磁单极子的麦克斯韦方程组](../photos/逻各斯与计算机编程艺术/3.svg)

1. **静电场的散度在局部由电荷密度给出。**
2. **静磁场的散度在局部由磁荷密度给出。**
3. **随时间变化的磁场与磁流，会在空间中激发出有旋的电场。**
4. **随时间变化的电场与电流，会在空间中激发出有旋的磁场。**

如果没有散度（div）、旋度（curl）这样的算子，麦克斯韦对电磁场的描述就只能是**一长串分量方程**：
到处都是偏导数、坐标分量和看不完的符号堆砌。这样的表达当然也是“正确”的，却缺乏整体感，更谈不上“美”。

而当人们引入了这些算子，把对电场和磁场分布与变化的理解**提升到更高一层的“算子语言”**时，一切都不一样了：原本冗长的描述被凝结成了几条形式极其统一的微分方程，甚至从形式的对称性中，人们可以大胆预言“磁单极子”这种尚未被观测到的对象。

所以，这里发生的，并不仅仅是“记号换了一套”，而是**认知结构被提升了一个维度**。这正说明，**一旦我们对世界的认知深度达到某个程度，表达形式自然会趋向简洁与统一**。抽象，并不是远离现实，而是更贴近本质。

# 观点二

当我们看待事物的角度发生变化，世界也就随之发生变化。

哲学家用“世界观”这个词来指称这种“看世界的角度”；程序员则更习惯用“范式（paradigm）”来描述一种固有的思维与设计方式。

你认为“世界的基本单位是什么”，决定了你如何去拆解、组织和重构它。从某种程度上来说，我们的每一次代码重构就是一次“革命”，一次范式转化。

要理解“范式转换”，首先得明白什么是“**范式**”。根据科学哲学家托马斯·库恩的定义，范式是“特定的科学共同体从事某一类科学活动所必须遵循的公认‘模式’”。它包括了共有的**世界观、基本理论、范例、方法、标准和工具**等。简而言之，范式是一个科学共同体成员所共享的一整套信念和实践规范。

所以用一句话概括这句话，可以是：

> 在所谓范式转化中，我们看到的一切没有变化，唯一变化的是我们看待这些事物的方式。

在计算机世界里，这种“看世界的方式”，最典型的体现就是各种不同的编程范式。接下来，我们就借几种大家耳熟能详的编程方式，来看看它们背后各自藏着怎样的世界观。

## 面向过程：世界是执行的步骤

如果从面向过程的视角来看世界，世界首先不是由“东西”构成的，而是由一件件按顺序发生的事构成的。程序是一串从上到下可以执行的指令，每一步都做一点小事，很多小步骤合起来，完成一个完整的任务。

在这个范式下，“做什么”和“先后顺序”是最重要的事情。你关心的是：先做 A，再做 B，遇到某个条件就走 C，不满足就走 D，然后循环多少次。这种视角下，脑海里的程序是一份流程图：有入口，有出口，中间拐几个弯，做几次判断和循环。

当系统很小的时候，这种看法几乎是本能。你甚至可以在脑子里模拟整个程序的执行：这行跑完，某个变量从一变成二，下一行再变成三，再下一行又被改回零。但当系统规模越来越大，并发、网络通信、事件驱动、分布式这些东西纷纷登场时，一条单线性的流程就显得吃力了。你不再只有一条清晰的主线，而是有成百上千个线程和协程同时跑；事件的顺序取决于用户、网络和调度器，而不是那几行写死的代码。你很难再用一句“现在执行到第几步了”来描述整个系统。

如果上帝是用纯面向过程的方式构建世界，大概也只有上帝自己维护得动。

## 面向对象：世界是实体的活动

从面向过程转向面向对象，我们的视线从流程转到了实体。在面向对象的世界观里，世界是由许多具有状态和行为的实体组成的系统，这些实体彼此作用，构成整体的结构与功能。我们开始更关心有哪些“角色”在场：用户、订单、账单、商品、会话、会话管理器……它们有什么属性，能做什么事情，有怎么样的生命周期，它们各自负责什么。

这和亚里士多德的那种“实体论”很像。他认为，世界由一个个具体的事物构成，这些事物是各种性质和关系的承担者。对应到程序世界里，就是那些具体的对象实例，以及生成它们的类。系统就是许多对象之间相互作用的结果。

当你用这种视角看系统，你会自然把注意力放在这样的问题上：这个系统里真正重要的角色有哪些？它们应该掌握哪些信息？承担哪些责任？要如何合作，才能完成我们期望的行为？当这些问题被回答得足够好，系统的轮廓就会变得清晰起来。你不再只盯着“执行到第几行”，而是可以说：“系统里有这么几类东西，它们之间是这样互动的。”

如果你写过游戏，这种转变会非常直观。一个简单的游戏世界里，有玩家，有敌人，有子弹，有地图，有道具。玩家有位置、血量、速度，有“移动”“攻击”“受伤”这些行为；敌人有自己的逻辑，子弹只负责飞行和碰撞检测，道具可以被拾取并改变玩家状态。你很少会去画一张从游戏启动到结束的总流程图，而更习惯画出“有哪些角色，它们怎么继承和组合”。当你想加一个新怪物，大多数时候只需要在现有的怪物类上稍作扩展；当你想加一个新武器，也就是定义一个新的武器对象，配置伤害和特效。世界从“一步步发生了什么”，变成了“一堆什么样的东西在同一个舞台上做各自的事”。

但随着系统继续变复杂，我们很快会发现，有时候真正让系统难以驾驭的地方，并不在于每个实体内部有多复杂，而在于它们之间织出的那张关系网：谁依赖谁，谁持有谁，谁回调谁。也就是说，光有“实体”的视角还不够，我们不得不再往前走一步，承认世界还是被关系编织出来的网络。

## 面向联系：世界是缘起的网络

如果说面向对象是把视角放在构成世界的实体之上，那么面向联系就是将视角从实体上迁移到实体上的相互关联中。

这和佛教中的 **“缘起性空”** 有天然的呼应。金刚经里写，凡所有相，皆是虚妄。若见诸相非相，即见如来。所谓“缘起”，就是因素和条件。由于万法产生均有其因素和条件。就是说世间上没有独存性的东西，也没有常住不变的东西，一切都是因缘和合所生起。所谓“性空”，就是说因缘和合所生起的假有，本性是空的。从这种角度来讲，我们之前面向对象的视角就是“着相”了。

在传统的面向对象编程中，我们倾向于将世界建模为一个个具有状态和行为的独立实体。对象本身被视为核心，对象间的交互则常被视为一种“次要”的派生特性。**面向联系**的范式则进行了一次彻底的视角转换：它将**实体间的相互关联视为第一性的、更本质的存在**。实体的意义和行为，并非由其内部孤立决定，而是在一个动态的关系网络中得以定义和显现。

在现代编程实践里，智能指针就是一个非常好的例子。传统的裸指针只管存一个内存地址，却完全没有表达“谁负责这块内存的生和死”。结果就是，释放早了会崩溃，释放晚了会泄漏。智能指针做的事情，是把“内存的生命周期”和“谁在管理它”这件事绑在一起。也就是说，资源的安全使用，不再依赖某个对象的“自觉”，而是由所有权关系来约束。简单讲，就是让“关系”而不是“个体”来决定何时创建，何时销毁。而它的成功也在于，它让我们不再执着于“谁是指针”的“相”，而是去设计和维护清晰的“缘起”。

在面向联系的世界观里，存在就是“在关系中存在”。离开了这些关系，所谓“实体”就像从图上被剪掉所有边的节点，虽然还在那儿，但几乎失去了意义。

## 面向函数：世界是求值的函数

函数式范式看世界的方式，比前面几种要抽象一些，但其实很贴近我们的一种直觉：很多时候，我们并不是在盯着“此刻的状态”，而是在看“东西是怎样一步步被改变”的。在函数式的世界里，世界被想象成一堆不会随便被改写的值，以及把这些值连接起来的一连串变换。程序的运行，不再是无数变量在原地被反复涂改，而更像是一个不断“化简表达式”的过程。

在这种视角下，你不再那么关心“这个变量现在是多少”，而更关心“它从最初的输入，到最后的输出，究竟经历了哪几步变化”。你会习惯把一个过程拆开来讲：先筛选，再转换，再分组，再汇总。每一步都只是把上一步的结果，稳稳当当地变成下一步的结果，中间没有人悄悄伸手去改“全局状态”。

如果从哲学的角度去看，这种世界观和莱布尼茨的“单子论”有一种很有趣的平行关系。单子论认为：世界由一种不可再分、各自自足的“单子”构成；单子之间并不存在那种你推我一下、我撞你一下的机械式作用，而是在一套“预定和谐”的秩序中，各自展开自己的变化；每一个单子，都以自己的方式“折射着整个宇宙”。对应到函数式编程中，那些不可变的值就像一个个小小的“单子”：它们是自足的、纯净的，不会被随意修改。函数与函数之间通过组合来协作，不是去共享一大坨可变状态，而是通过输入和输出彼此“对接”；至于那些难以避免的副作用，则被关进特定的结构里（比如 Monad 或各种 Effect 系统），核心的运算部分尽量保持纯粹。

很多人在尝试用函数式思路重构旧代码时，会体验到一种非常鲜明的对比：原来的代码里到处都是临时变量和“当前状态”的修改，你要解释它在做什么，只能老老实实从头到尾复述一遍：“这里改了一下，那边又改了一下”；而当你把同样的逻辑改写成一串变换之后，它突然变得容易讲了许多：这一段专门用来过滤数据，那一段专门用来计算总数，再下一段负责把结果整理成想要的格式。

可以说，函数式范式帮我们把注意力，从“此刻这个东西长成什么样”，挪到了“它是如何一步步变成现在这样”的结构本身。在这种世界观里，世界不再是一堆随时可能被改写的“现状”，而更像是一条条从输入通向输出的变换链条。

# 总结

看起来这些东西离我们每天写代码的生活很遥远，但如果你把注意力稍微往后退半步，会发现它们都在悄悄回答同一个问题：

> **当我们说“世界是什么”的时候，我们其实在说什么？**
> 当我们说“这个系统是这样设计的”，我们其实默认了怎样的一套世界观？

所以，那句“20% 哲学，80% 专业知识”，并不是在鼓励大家去变成“哲学专业的程序员”，而是想表达一种更朴素地期待：

写代码的时候问一句，“我是在用哪种世界观在看这个系统？”，设计抽象的时候想一下，“我真的抓住问题本质了吗？”，面对不同范式的时候，考虑下，“在这种问题上哪种视角更自然？”

如果说计算机科学是在寻找“如何让机器正确地运行”，那哲学在做的，或许是帮助我们回答：**在一切这些运行背后，我们到底认为“世界是怎样的”？**。

而编程之道就在其中——写下你关于这个世界的认识。